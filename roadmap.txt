Roadmap de Mejoras Pre-Frontend - Notification Hub ðŸŽ¯
 
ðŸ”´ BUGS CRÃTICOS - ARREGLAR ANTES QUE NADA

1. Race Condition en Rate Limiting
Archivo: RateLimitService.java
Problema: Dos usuarios pueden enviar mensajes simultÃ¡neamente y ambos incrementar el contador, superando el lÃ­mite
SoluciÃ³n: Implementar lock optimista con @Version en la entidad DailyMessageCount O usar una query SQL atÃ³mica que incremente directamente en base de datos
Impacto: Alta - Los usuarios pueden hacer spam

2. Fallo de Transaccionalidad en EnvÃ­o de Mensajes
Archivo: MessageServiceImpl.java - mÃ©todo sendMessage()
Problema: Si todas las plataformas fallan, el mensaje queda guardado y cuenta en el lÃ­mite diario aunque nunca se enviÃ³ nada
SoluciÃ³n: Verificar que al menos UNA plataforma tuvo Ã©xito antes de commitear la transacciÃ³n, sino hacer rollback completo
Impacto: Alta - Los usuarios pierden cuota de mensajes sin recibir nada

3. N+1 Query Problem
Archivo: MessageRepository.java y MessageServiceImpl.java
Problema: Al buscar mensajes con findAll(), cada mensaje dispara una query adicional para cargar sus deliveries (entregas)
SoluciÃ³n: Agregar @EntityGraph o JOIN FETCH en el repository para cargar deliveries de una sola vez
Impacto: Media-Alta - Con 100 mensajes = 101 queries a BD

4. Rate Limit Check DespuÃ©s del Save
Archivo: MessageServiceImpl.java - mÃ©todo sendMessage()
Problema: Se incrementa el rate limit ANTES de verificar si el mensaje se pudo enviar
SoluciÃ³n: Primero intentar enviar, LUEGO incrementar solo si hubo Ã©xito
Impacto: Media - Los fallos cuentan como mensajes enviados
 
ðŸŸ¡ MEJORAS DE ARQUITECTURA - REFACTORING IMPORTANTE

5. Separar Responsabilidades en MessageService
Archivos: MessageServiceImpl.java (crear 3 nuevos servicios)
Problema: MessageServiceImpl hace TODO: persiste, envÃ­a, valida, filtra (viola Single Responsibility Principle)
SoluciÃ³n:
Crear MessageOrchestratorService (coordina el flujo)
Crear MessagePersistenceService (solo CRUD)
Crear NotificationDispatcher (solo envÃ­o a plataformas)
Crear MessageFilterService (solo lÃ³gica de filtros)
Impacto: Baja en funcionalidad, Alta en mantenibilidad

6. Circuit Breaker para Plataformas Externas
Archivos: TelegramServiceImpl.java y DiscordServiceImpl.java
Problema: Si Telegram/Discord caen, cada request espera timeout (lento y consume recursos)
SoluciÃ³n: Agregar dependencia resilience4j-spring-boot3 y decorar mÃ©todos send() con @CircuitBreaker y @Retry
ConfiguraciÃ³n: Archivo application.yml con sliding window de 10 requests, umbral de fallo 50%, espera de 60s
Impacto: Alta - Mejora resiliencia y UX

7. Implementar CachÃ© Inteligente
Archivos: MessageServiceImpl.java, crear CacheConfig.java
Problema: Cada vez que el usuario lista sus mensajes, se consulta BD
SoluciÃ³n:
Agregar @EnableCaching en configuraciÃ³n
Usar Caffeine como provider (en memoria)
Decorar getMyMessages() con @Cacheable
Invalidar con @CacheEvict al enviar nuevo mensaje
Impacto: Media - Reduce carga en BD hasta 80%

8. AuditorÃ­a AutomÃ¡tica con Spring Data
Archivos: Todas las entidades (Message.java, User.java, etc.) y crear JpaAuditConfig.java
Problema: No hay trazabilidad de quiÃ©n creÃ³/modificÃ³ quÃ© y cuÃ¡ndo
SoluciÃ³n:
Agregar @CreatedDate, @LastModifiedDate, @CreatedBy, @LastModifiedBy a entidades
Configurar @EnableJpaAuditing con AuditorAware que obtenga usuario del SecurityContext
Impacto: Baja - Pero crÃ­tica para compliance
 
ðŸŸ¢ FUNCIONALIDADES CLAVE PARA EL FRONTEND

9. Sistema de Plantillas de Mensajes
Crear: MessageTemplate.java (entidad), MessageTemplateRepository.java, TemplateService.java, TemplateController.java
Funcionalidad: Usuario guarda plantillas con placeholders tipo {username}, {fecha}, etc.
Endpoints:
POST /api/templates - Crear plantilla
GET /api/templates - Listar mis plantillas
POST /api/messages/send-from-template - Enviar usando plantilla + variables
Impacto: Alta - Feature killer para UI

10. Mensajes Programados (Scheduled Messages)
Crear: ScheduledMessage.java (entidad), ScheduledMessageRepository.java, ScheduledMessageService.java con @Scheduled
Funcionalidad: Usuario programa mensajes para enviarse en fecha/hora especÃ­fica
Endpoints:
POST /api/scheduled-messages - Programar mensaje
GET /api/scheduled-messages - Ver mis mensajes pendientes
DELETE /api/scheduled-messages/{id} - Cancelar programado
Cron Job: Revisar cada minuto mensajes pendientes y enviar los que llegaron a su hora
Impacto: Alta - Diferenciador clave

11. Dashboard de EstadÃ­sticas
Crear: DashboardController.java, DashboardService.java
Funcionalidad: Endpoint que devuelve stats para el frontend
Endpoint: GET /api/dashboard/stats
Retorna:
Total mensajes enviados
Mensajes por plataforma (Telegram vs Discord)
Tasa de Ã©xito/fallo
Mensajes enviados hoy
Cuota restante del dÃ­a
GrÃ¡fica Ãºltimos 7 dÃ­as
Impacto: Alta - Core del frontend

12. Webhooks para Integraciones Externas
Crear: WebhookSubscription.java (entidad), WebhookService.java, WebhookController.java
Funcionalidad: Usuario registra una URL webhook para recibir notificaciones cuando ocurren eventos
Eventos: MESSAGE_SENT, MESSAGE_FAILED, RATE_LIMIT_REACHED
Seguridad: Firmar payloads con HMAC usando un secreto compartido
Endpoints:
POST /api/webhooks - Registrar webhook
GET /api/webhooks - Listar mis webhooks
DELETE /api/webhooks/{id} - Eliminar webhook
Impacto: Media - Para usuarios avanzados

13. BÃºsqueda Full-Text en Mensajes
Modificar: MessageRepository.java, agregar Ã­ndice FULLTEXT en Message.content
Funcionalidad: Buscar mensajes por palabras clave en el contenido
Endpoint: GET /api/messages/search?q=palabra
ImplementaciÃ³n: Query nativa MySQL con MATCH() AGAINST() en modo natural language
Impacto: Media - Mejora UX significativamente

14. MÃ©tricas Detalladas con Micrometer
Modificar: Todos los servicios, agregar dependencia micrometer-registry-prometheus
Funcionalidad: Exponer mÃ©tricas tÃ©cnicas para monitoreo
MÃ©tricas custom:
Counter de mensajes enviados por plataforma
Timer de duraciÃ³n de envÃ­o
Gauge de usuarios activos
Gauge de rate limit promedio
Endpoint: GET /actuator/prometheus (auto-generado)
Impacto: Baja para usuarios, Alta para ops

15. EnvÃ­o Masivo AsÃ­ncrono (Batch)
Crear: BatchController.java, modificar MessageServiceImpl.java
Funcionalidad: Enviar mÃºltiples mensajes en un solo request, procesados en background
Endpoints:
POST /api/messages/send-batch - Enviar lista de mensajes, retorna batchId
GET /api/messages/batch-status/{batchId} - Consultar progreso
ImplementaciÃ³n: Usar CompletableFuture.runAsync() o @Async
Impacto: Media - Para power users

16. Rate Limiting Avanzado con Bucket4j
Reemplazar: RateLimitService.java completo
Funcionalidad: Cambiar de contador diario simple a token bucket con refill
Beneficio:
MÃ¡s granular (por minuto/hora en vez de solo dÃ­a)
Respuestas HTTP con headers X-RateLimit-Remaining, X-RateLimit-Reset
Diferentes lÃ­mites por rol (ADMIN sin lÃ­mite, USER 100/dÃ­a)
Impacto: Media - Mejora UX con feedback visual

17. Soporte para Archivos Adjuntos
Modificar: MessageController.java, TelegramServiceImpl.java, DiscordServiceImpl.java
Funcionalidad: Enviar mensajes con imÃ¡genes/documentos adjuntos
Endpoint: POST /api/messages/send-with-file (multipart/form-data)
Validaciones:
TamaÃ±o mÃ¡ximo 10MB
Tipos permitidos: image/*, application/pdf
Storage: Guardar en sistema de archivos local o S3
ImplementaciÃ³n: Telegram y Discord tienen APIs nativas para enviar archivos
Impacto: Alta - Feature muy solicitado
 
ðŸ“Š PRIORIZACIÃ“N RECOMENDADA

ðŸ”¥ Semana 1 - Arreglar Fundamentos
Race condition en rate limiting
Transaccionalidad del envÃ­o
N+1 queries fix
Separar responsabilidades (refactor)
Circuit breaker bÃ¡sico

âš¡ Semana 2 - Features Core para Frontend
Sistema de plantillas
Dashboard de estadÃ­sticas
Mensajes programados
CachÃ© con Caffeine
BÃºsqueda full-text

ðŸŽ¨ Semana 3 - Features Avanzados
Rate limiting con Bucket4j (headers informativos)
Webhooks
EnvÃ­o masivo
MÃ©tricas con Micrometer
AuditorÃ­a automÃ¡tica

ðŸš€ Semana 4 - Polish y Deployment
Soporte para archivos
Testing exhaustivo de todas las features nuevas
OptimizaciÃ³n de queries
DocumentaciÃ³n Swagger actualizada
Preparar deployment con nuevas variables de entorno
 
ðŸ’¡ CONSIDERACIONES TÃ‰CNICAS IMPORTANTES
Para el Frontend
Los endpoints de dashboard deben retornar JSON con estructura clara (no solo entidades crudas)
Implementar CORS correctamente para permitir localhost:3000 en desarrollo
Considerar WebSockets para notificaciones en tiempo real (opcional, alta complejidad)
Todos los endpoints deben devolver DTOs, nunca entidades directamente
Seguridad
Revisar que TODOS los endpoints estÃ©n protegidos con JWT (excepto /api/auth/*)
Validar TODOS los inputs con Bean Validation (@Valid)
Sanitizar contenido de mensajes para prevenir XSS si el frontend renderiza HTML
Rotar JWT_SECRET periÃ³dicamente en producciÃ³n
Performance
Implementar paginaciÃ³n en TODOS los endpoints que retornan listas (Pageable)
Usar proyecciones JPA para queries de solo lectura (evitar cargar entidades completas)
Configurar pool de conexiones adecuado en application.yml (HikariCP)
Considerar Redis para cachÃ© distribuida si escala mÃ¡s allÃ¡ de un servidor
Observabilidad
Logs estructurados en JSON con timestamp, level, clase, mensaje
Correlation IDs para rastrear requests a travÃ©s de microservicios
Health checks detallados que verifiquen BD + plataformas externas
Alertas cuando rate de fallo > 20%
 
ðŸŽ¯ PRÃ“XIMOS PASOS CONCRETOS
Crear branch: git checkout -b refactor/pre-frontend-improvements
Arreglar bugs crÃ­ticos (1-4) en orden de prioridad
Hacer PR pequeÃ±os (no todo junto) para facilitar review
Escribir tests para cada cambio ANTES de implementar
Actualizar Swagger con cada nuevo endpoint
Documentar decisiones tÃ©cnicas en el README
Tiempo estimado total: 3-4 semanas trabajando part-time
 
